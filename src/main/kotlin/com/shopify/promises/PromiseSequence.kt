/*
 *   The MIT License (MIT)
 *
 *   Copyright (c) 2017 Shopify Inc.
 *
 *   Permission is hereby granted, free of charge, to any person obtaining a copy
 *   of this software and associated documentation files (the "Software"), to deal
 *   in the Software without restriction, including without limitation the rights
 *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *   copies of the Software, and to permit persons to whom the Software is
 *   furnished to do so, subject to the following conditions:
 *
 *   The above copyright notice and this permission notice shall be included in
 *   all copies or substantial portions of the Software.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *   THE SOFTWARE.
 */
@file:JvmName("PromiseSequenceUtils")

package com.shopify.promises

import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicReference

class PromiseSequence<T, E> private constructor(private val sequence: Sequence<Promise<T, E>>) {

  internal companion object {

    fun <T, E> generate(seed: T, next: (T) -> Promise<T, E>?): PromiseSequence<T, E> {
      val lastValue = AtomicReference<T>(seed)
      val canceled = AtomicBoolean()
      return PromiseSequence(
        generateSequence { if (canceled.get()) null else next(lastValue.get()) }
          .map { it.onReject { canceled.set(true) } }
          .map { it.onResolve { lastValue.set(it) } }
      )
    }

    fun <T, E> generate(next: () -> Promise<T, E>?): PromiseSequence<T, E> {
      val canceled = AtomicBoolean()
      return PromiseSequence(
        generateSequence { if (canceled.get()) null else next() }
          .map { it.onReject { canceled.set(true) } }
      )
    }
  }

  /**
   * Accumulates success resolved [Promise] execution generated by sequence starting with the first element and applying [accumulator] from
   * left to right to current accumulator value and each element.
   *
   * @param initial accumulator value
   * @param accumulator function to accumulate success resolved [Promise] execution values
   * @return [Promise]`<A, E>` that is resolved with accumulated success execution results or rejected with the first [Promise] failure from
   * the sequence
   */
  fun <A> reduce(initial: A, accumulator: (acc: A, value: T) -> A): Promise<A, E> {
    fun Iterator<Promise<T, E>>.reduceAsync(accumulated: A, delegateResult: (Promise.Result<A, E>) -> Unit) {
      val nextPromise = if (hasNext()) next() else null
      nextPromise?.whenComplete(
        onResolve = { reduceAsync(accumulator(accumulated, it), delegateResult) },
        onReject = { delegateResult(Promise.Result.Error(it)) }
      ) ?: delegateResult(Promise.Result.Success(accumulated))
    }
    return Promise<A, E> {
      val delegateCancel = AtomicReference({})
      onCancel {
        delegateCancel.get().invoke()
      }
      sequence.onEach { delegateCancel.set(it::cancel) }
        .iterator()
        .reduceAsync(initial) { dispatch(it) }
    }
  }

  /**
   * Accumulates success resolved [Promise] execution generated by sequence.
   *
   * @return [Promise]`<List<T>, E>` that is resolved with accumulated success execution results or rejected with the first [Promise] failure from
   * the sequence
   */
  fun reduce(): Promise<List<T>, E> = reduce(emptyList()) { acc, value -> acc + value }
}

/**
 * Constructs the [PromiseSequence] that generates sequence of promises provided by function [next]
 *
 * @param seed  to start the sequence with
 * @param next function to be used for sequence generator that takes previously success resolved value of [Promise] execution and returns
 * the next one until it returns `null` that signals the end of the sequence or until first [Promise] execution failure
 * @return [PromiseSequence]`<T, E>`
 */
fun <T, E> Promise.Companion.sequence(seed: T, next: (T) -> Promise<T, E>?): PromiseSequence<T, E> = PromiseSequence.generate(seed, next)

/**
 * Constructs the [Promise] that is resolved with [Sequence] of promises generated by the provided function [next]
 *
 * @param next function to be used for sequence generator that returns the next [Promise] until `null` that signals the end of the sequence
 *
 * @return [Promise]`<Sequence<Promise<T, E>>, Nothing>`
 */
fun <T, E> Promise.Companion.sequence(next: () -> Promise<T, E>?): PromiseSequence<T, E> = PromiseSequence.generate(next)